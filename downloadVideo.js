/**
 * downloadVideo.js
 * G√®re le t√©l√©chargement d‚Äôune vid√©o YouTube en format "video only" (pas de piste audio).
 */

const fs = require('fs');
const path = require('path');
const ytdl = require('@distube/ytdl-core');
const cliProgress = require('cli-progress');
const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const AdblockerPlugin = require('puppeteer-extra-plugin-adblocker');

const COOKIES_PATH = 'cookies.json';

// Appliquer les plugins pour √©viter la d√©tection des bots
puppeteer.use(StealthPlugin());
puppeteer.use(AdblockerPlugin({ blockTrackers: true }));

/**
 * V√©rifie si le fichier `cookies.json` existe.
 * @returns {boolean} - Retourne `true` si le fichier existe, sinon `false`.
 */
function cookiesExist() {
  return fs.existsSync(COOKIES_PATH);
}

async function setCookiesFromFile(page) {
  if (cookiesExist()) {
    const cookies = JSON.parse(fs.readFileSync(COOKIES_PATH, 'utf8'));
    await page.setCookie(...cookies);
    console.log('üç™ Cookies charg√©s dans le navigateur.');
  }
}


/**
 * R√©cup√®re les cookies de YouTube via Puppeteer et les enregistre dans `cookies.json`.
 * @returns {Promise<Array>} - Un tableau d'objets cookie.
 */
async function getYoutubeCookies() {
  const browser = await puppeteer.launch({
    executablePath: '/usr/bin/chromium-browser',
    headless: true,
    protocolTimeout: 90000,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-gpu',
      '--disable-software-rasterizer',
      '--disable-dev-shm-usage',
      '--disable-features=NetworkService,NetworkServiceInProcess',
      '--disable-background-networking',
      '--disable-extensions',
      '--disable-breakpad',
      '--disable-sync',
      '--disable-blink-features=AutomationControlled',
      '--remote-debugging-port=9222'
    ],
  });

  const page = await browser.newPage();
  await page.setViewport({ width: 1280, height: 720 });

  // ‚úÖ R√©injecte les cookies existants
  await setCookiesFromFile(page);

  await page.evaluateOnNewDocument(() => {
    Object.defineProperty(navigator, 'webdriver', { get: () => false });
  });

  await page.goto('https://www.youtube.com', { waitUntil: 'networkidle2' });

  // ‚úÖ V√©rifie si YouTube demande une connexion (captcha, login‚Ä¶)
  if ((await page.url()).includes('consent.youtube.com')) {
    console.log('‚ö†Ô∏è YouTube demande une validation manuelle. Ouvre la session pour valider.');
    await page.screenshot({ path: 'captcha.png' });
    await page.waitForTimeout(10000); // Pause pour intervention manuelle
  }

  const cookies = await page.cookies();
  fs.writeFileSync(COOKIES_PATH, JSON.stringify(cookies, null, 2));
  console.log('‚úÖ Cookies mis √† jour.');

  await browser.close();
  return cookies;
}


/**
 * Charge les cookies de YouTube depuis `cookies.json` ou les r√©cup√®re avec Puppeteer si n√©cessaire.
 * @returns {Promise<Array>} - Tableau des cookies.
 */
async function loadCookies() {
  if (cookiesExist()) {
    console.log('üìÇ Chargement des cookies depuis cookies.json');
    return JSON.parse(fs.readFileSync(COOKIES_PATH, 'utf8'));
  } else {
    console.log('üîÑ R√©cup√©ration des cookies via Puppeteer...');
    return await getYoutubeCookies();
  }
}

/**
 * Cr√©e un agent pour ytdl-core en utilisant les cookies r√©cup√©r√©s.
 * @returns {Promise<Object>} - L'agent cr√©√© par ytdl.createAgent.
 */
async function createYtdlAgent() {
  const cookies = await loadCookies();
  return ytdl.createAgent(cookies);
}

// Headers suppl√©mentaires pour imiter un vrai navigateur
const defaultHeaders = {
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
  'Accept-Language': 'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',
  'Referer': 'https://www.youtube.com/'
};

/**
 * T√©l√©charge la vid√©o depuis YouTube (sans piste audio).
 * @param {string} url - L‚ÄôURL de la vid√©o YouTube.
 * @param {string} outputDir - Le dossier de sortie.
 * @returns {Promise<string>} - Le chemin du fichier t√©l√©charg√©.
 */
const downloadVideoOnly = async (url, outputDir) => {
  try {
    // Cr√©er l'agent avec cookies r√©cup√©r√©s
    const agent = await createYtdlAgent();

    // Extraire l‚ÄôID de la vid√©o
    const videoId = new URL(url).searchParams.get('v');
    if (!videoId) {
      throw new Error('Impossible d‚Äôextraire l‚ÄôID de la vid√©o');
    }

    const fileName = `vod_${videoId}_noaudio.mp4`;
    const outputPath = path.join(outputDir, fileName);

    console.log(`üì• T√©l√©chargement de la vid√©o sans audio : ${fileName}...\n`);

    // R√©cup√©rer les informations sur la vid√©o
    const info = await ytdl.getInfo(url, { agent, headers: defaultHeaders });
    const format = ytdl.chooseFormat(info.formats, {
      quality: 'highestvideo',
      filter: 'videoonly',
    });
    const totalSize = parseInt(format.contentLength, 10) || 0;

    // Initialiser la barre de progression
    const progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
    progressBar.start(totalSize, 0);

    let downloadedSize = 0;

    // T√©l√©charger la vid√©o
    await new Promise((resolve, reject) => {
      ytdl(url, { 
          quality: 'highestvideo', 
          filter: 'videoonly',
          agent,
          headers: defaultHeaders 
        })
        .on('progress', (chunkLength) => {
          downloadedSize += chunkLength;
          progressBar.update(downloadedSize);
        })
        .pipe(fs.createWriteStream(outputPath))
        .on('finish', () => {
          progressBar.update(totalSize);
          progressBar.stop();
          console.log(`‚úÖ T√©l√©chargement termin√© : ${outputPath}`);
          resolve();
        })
        .on('error', (err) => {
          progressBar.stop();
          reject(err);
        });
    });

    return outputPath;
  } catch (error) {
    console.error('‚ùå Erreur lors du t√©l√©chargement :', error.message);
    throw error;
  }
};

module.exports = downloadVideoOnly;
